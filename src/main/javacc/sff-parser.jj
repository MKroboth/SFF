/*-
 * #%L
 * Cactis SFF
 * %%
 * Copyright (C) 2019 Maximilian Kroboth
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Lesser Public License for more details.
 *
 * You should have received a copy of the GNU General Lesser Public
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/lgpl-3.0.html>.
 * #L%
 */
PARSER_BEGIN(SFFParser)
package eu.cactis.sff.parser;
/*-
 * #%L
 * Cactis SFF
 * %%
 * Copyright (C) 2019 Maximilian Kroboth
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Lesser Public License for more details.
 *
 * You should have received a copy of the GNU General Lesser Public
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/lgpl-3.0.html>.
 * #L%
 */
import eu.cactis.sff.*;
import java.util.List;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.Map;
import java.util.Hashtable;
import java.util.Arrays;
import java.util.Collections;

public class SFFParser {
    private String resolveEscapeSequence(String escapeSequence) {
        escapeSequence = escapeSequence.substring(1);
        switch (escapeSequence) {
            case "n": return "\n";
            case "r": return "\r";
            default:
                return escapeSequence;
        }
    }

}
PARSER_END(SFFParser)

// TODO: Add quoted strings and block quoted strings.

SKIP : { "\r" | "\n" | "\t" | " " }
TOKEN : { <#ALPHA : [
   "\u0041"-"\u005a", // Latin Alphabet(upper case)
   "\u005f",  // Underscore
   "\u0061"-"\u007a", // Latin Alphabet(lower case)
   "\u00c0"-"\u00d6", // Letters: Uppercase
   "\u00d8"-"\u00f6", // Letters: Lowercase
   "\u00f8"-"\u00ff", // Letters: Lowercase
   "\u0100"-"\u1fff", // Stuff
   "\u3040"-"\u318f",
   "\u3300"-"\u337f",
   "\u3400"-"\u3d2d",
   "\u4e00"-"\u9fff",
   "\uf900"-"\ufaff"]> }
TOKEN : { <#NUMERIC : ["0"-"9"]> }
TOKEN : { <#ALPHANUM : (<ALPHA>)|(<NUMERIC>) >}
<DEFAULT> TOKEN : { <IDENTIFIER : (<ALPHA> | "-") (<ALPHANUM> | "-")* > }
TOKEN : { <BEGIN_GROUP : "{" > }
TOKEN : { <END_GROUP : "}" > }

TOKEN : { <BEGIN_COMMENT : "#"> : COMMENT_STATE }
<ASSIGNMENT_STATE> TOKEN : { <TEXT_CONTENT : (~["\r", "\n"])+ > }
<ASSIGNMENT_STATE> TOKEN : { <END_ASSIGNMENT : ["\r", "\n"]> : DEFAULT }
<COMMENT_STATE> TOKEN : { <COMMENT_CONTENT : (~["\r", "\n"])+ > }
<COMMENT_STATE> TOKEN : { <END_COMMENT : ["\r", "\n"]> : DEFAULT }

TOKEN : { <BEGIN_PI : "@">: PI_STATE }
<PI_STATE> TOKEN : { <PI_ID_CONTENT : (~["\r", "\n", "\t", " "])+ [" ", "\t"]>: PI_STATE_CNT }
<PI_STATE_CNT> TOKEN : { <PI_CONTENT : (~["\r", "\n", "\t", " "])+(~["\r", "\n"])* > }
<PI_STATE_CNT> TOKEN : { <END_PI : ["\r", "\n"]> : DEFAULT }

TOKEN : { <#ESCAPE_SEQUENCE: "\\" ["<", ">", ",", "\"", "(", ")", "{", "}", "[", "]", "\\", "n", "r", "v", "=", "#", "@"] >}


TOKEN : { <BEGIN_PLIST : "(" > : PLIST_STATE }
<PLIST_STATE> TOKEN :  { <END_PLIST : ")">: DEFAULT }
<PLIST_STATE> TOKEN : { <PLIST_CONTENT : (~[")"])+> }

TOKEN : { <BEGIN_TEXT : "<" > : TEXT_STATE }
<TEXT_STATE> TOKEN : { <TS_ESCAPED_STRING : <ESCAPE_SEQUENCE>> }
<TEXT_STATE> TOKEN : { <END_TEXT : ">" > : DEFAULT }
<TEXT_STATE> TOKEN : { <TEXTBLOCK_CONTENT : (~["<",">"," ","\\"])(~["<",">","\\"])* > }
TOKEN : { <BEGIN_AMAP : "[" > : AMAP_STATE }
<AMAP_STATE> TOKEN : { <COLON : ":" > }
<AMAP_STATE> TOKEN : { <COMMA : "," > }
<AMAP_STATE> TOKEN : { <END_AMAP : "]" >: DEFAULT }
<AMAP_STATE> TOKEN : { <AMAP_ENTITY : (~["]",",",":"])+ > }

TOKEN : { <BEGIN_ASSIGNMENT : "=" (" ")* > : ASSIGNMENT_STATE }


List Start():
{ List nodes = new LinkedList(); Node nd; }{
 ( ( nd = PNode()) { nodes.add(nd); })+
 { return nodes; }
}

Node PNode():
{ Node ret; }
{
  (( ret = PDataNode() ) | (ret = PMetaDataNode()))

  { return ret; }
}
GroupNode PGroupNode(String name, List properties, Map attributes):
{ Token t;
    Node nd;
    List children = new LinkedList(); }
{
    <BEGIN_GROUP>
    (nd = PNode() {children.add(nd);})*
    <END_GROUP>

    { return new GroupNode(name, properties, attributes, children); }
}

Node PCommentNode():
{ Token t; String content = ""; }
{
    <BEGIN_COMMENT>
    (t = <COMMENT_CONTENT> { content = t.image.trim(); })?
    <END_COMMENT>

    { return new CommentNode(content); }
}

Node PProcessingInstructionNode():
{ Token t; String name; String content = ""; }
{
    <BEGIN_PI>
    t = <PI_ID_CONTENT> { name = t.image.trim(); }
    (t = <PI_CONTENT> { content = t.image.trim(); })?
    <END_PI>

    { return new ProcessingInstructionNode(name, content); }
}

Node PMetaDataNode(): {Node nd;} {
   ((nd = PCommentNode()) | (nd = PProcessingInstructionNode()) | (nd = PTextNode()))

   { return nd; }
}

Node PTextNode(): { Token t; StringBuilder sb = new StringBuilder(); } {
    <BEGIN_TEXT>

    ((t = <TEXTBLOCK_CONTENT> { sb.append(t.image); })|(t = <TS_ESCAPED_STRING> { sb.append(resolveEscapeSequence(t.image)); }))*
    <END_TEXT>
    { return new TextNode(sb.toString()); }
}

List PPList():
{Token content; }{
    <BEGIN_PLIST>
    content  = <PLIST_CONTENT>
    <END_PLIST>

    {return Arrays.asList(content.image.split(" ")); }
}

Map PAMap():
{Token elem; String k; String v; Map map = new Hashtable(); }
{
    <BEGIN_AMAP>
    elem = <AMAP_ENTITY> { k = elem.image;} <COLON> elem = <AMAP_ENTITY> { v = elem.image; map.put(k,v);}
    ( <COMMA> elem = <AMAP_ENTITY> { k = elem.image;} <COLON> elem = <AMAP_ENTITY> { v = elem.image; map.put(k,v);})*
    <END_AMAP>

    { return map; }
}
Node  PDataNode():
{ Token t; Node nd; String name = null; List properties = new LinkedList(); Map attributes = new Hashtable(); }
{
    t = <IDENTIFIER> { name = t.image.trim(); }
    (properties = PPList())?
    (attributes = PAMap())?
    (( nd = PPropertyNode(name, properties, attributes)) | ( nd = PGroupNode(name, properties, attributes)) | (
        nd = PTextNode()
        { nd = new GroupNode(name, properties, attributes, Collections.singletonList(nd)); }
    ))

    { return nd; }
}

PropertyNode PPropertyNode(String name, List properties, Map attributes):
{ Token t; String value = ""; }
{
    <BEGIN_ASSIGNMENT>
   (t = <TEXT_CONTENT> {value = t.image; })?
    <END_ASSIGNMENT>

    { return new PropertyNode(name, properties, attributes, value.trim()); }
}